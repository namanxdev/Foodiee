-- ============================================================
-- Recipe Database Schema for Scalability
-- Run this in Supabase SQL Editor
-- ============================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ============================================================
-- 1. Recipes Table (Core Data)
-- ============================================================

CREATE TABLE IF NOT EXISTS recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE,
    
    -- Categories
    cuisine_type TEXT NOT NULL, -- Indian, Chinese, Italian, Mexican, Japanese
    meal_type TEXT[] NOT NULL, -- {breakfast, lunch, dinner, snack}
    
    -- Cooking info
    prep_time_minutes INT NOT NULL,
    cooking_time_minutes INT NOT NULL,
    total_time_minutes INT GENERATED ALWAYS AS (prep_time_minutes + cooking_time_minutes) STORED,
    difficulty TEXT NOT NULL CHECK (difficulty IN ('easy', 'medium', 'hard')),
    servings INT DEFAULT 4,
    
    -- Taste & Dietary
    taste_profile TEXT[] NOT NULL, -- {sweet, spicy, savory, sour, tangy}
    allergens TEXT[] DEFAULT '{}', -- {dairy, nuts, gluten, shellfish}
    dietary_tags TEXT[] DEFAULT '{}', -- {vegetarian, vegan, gluten-free, keto}
    
    -- Recipe Content
    ingredients JSONB NOT NULL, 
    -- Format: [{"name": "chicken", "amount": "500g", "optional": false}]
    
    steps TEXT[] NOT NULL, 
    -- Format: {"Step 1: ...", "Step 2: ..."}
    
    tips TEXT,
    
    -- Search & Ranking
    embedding vector(768), -- For semantic search using Google's text-embedding-004
    popularity_score FLOAT DEFAULT 0, -- Track which recipes users select
    
    -- Metadata
    source TEXT, -- "Generated by AI", "From cookbook X"
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for fast filtering
CREATE INDEX IF NOT EXISTS idx_recipes_cuisine ON recipes(cuisine_type);
CREATE INDEX IF NOT EXISTS idx_recipes_meal_type ON recipes USING GIN(meal_type);
CREATE INDEX IF NOT EXISTS idx_recipes_taste ON recipes USING GIN(taste_profile);
CREATE INDEX IF NOT EXISTS idx_recipes_dietary ON recipes USING GIN(dietary_tags);
CREATE INDEX IF NOT EXISTS idx_recipes_time ON recipes(total_time_minutes);
CREATE INDEX IF NOT EXISTS idx_recipes_difficulty ON recipes(difficulty);
CREATE INDEX IF NOT EXISTS idx_recipes_popularity ON recipes(popularity_score DESC);

-- Vector search index (for semantic similarity)
CREATE INDEX IF NOT EXISTS idx_recipes_embedding ON recipes 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- ============================================================
-- 2. Recipe Images Table
-- ============================================================

CREATE TABLE IF NOT EXISTS recipe_images (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
    
    image_type TEXT NOT NULL, -- 'hero', 'step_1', 'step_2', etc.
    image_url TEXT NOT NULL, -- Supabase Storage URL
    thumbnail_url TEXT, -- Smaller version for listings
    
    -- Generation metadata
    prompt_used TEXT,
    generated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(recipe_id, image_type)
);

CREATE INDEX IF NOT EXISTS idx_images_recipe ON recipe_images(recipe_id);
CREATE INDEX IF NOT EXISTS idx_images_type ON recipe_images(image_type);

-- ============================================================
-- 3. User Sessions Table (Persistent Sessions)
-- ============================================================

CREATE TABLE IF NOT EXISTS user_sessions (
    session_id TEXT PRIMARY KEY,
    
    -- User preferences
    user_preferences JSONB NOT NULL,
    
    -- Current state
    current_recipe_id UUID REFERENCES recipes(id) ON DELETE SET NULL,
    current_step_index INT DEFAULT 0,
    completed_steps TEXT[] DEFAULT '{}',
    
    -- Interaction history
    viewed_recipes UUID[] DEFAULT '{}',
    selected_recipe_name TEXT,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    last_accessed TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP DEFAULT (NOW() + INTERVAL '24 hours')
);

CREATE INDEX IF NOT EXISTS idx_sessions_last_accessed ON user_sessions(last_accessed);
CREATE INDEX IF NOT EXISTS idx_sessions_expires ON user_sessions(expires_at);

-- Auto-cleanup function for old sessions
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS void AS $$
BEGIN
    DELETE FROM user_sessions WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- 4. Recipe Analytics Table (Track Usage)
-- ============================================================

CREATE TABLE IF NOT EXISTS recipe_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
    
    event_type TEXT NOT NULL, -- 'viewed', 'selected', 'completed'
    session_id TEXT,
    
    -- Additional context
    user_preferences JSONB,
    
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_analytics_recipe ON recipe_analytics(recipe_id);
CREATE INDEX IF NOT EXISTS idx_analytics_event ON recipe_analytics(event_type);
CREATE INDEX IF NOT EXISTS idx_analytics_created ON recipe_analytics(created_at);

-- ============================================================
-- 5. Materialized View for Popular Recipes
-- ============================================================

CREATE MATERIALIZED VIEW IF NOT EXISTS popular_recipes AS
SELECT 
    r.id,
    r.name,
    r.cuisine_type,
    r.total_time_minutes,
    COUNT(a.id) FILTER (WHERE a.event_type = 'selected') as selection_count,
    COUNT(a.id) FILTER (WHERE a.event_type = 'completed') as completion_count,
    COUNT(a.id) FILTER (WHERE a.event_type = 'viewed') as view_count,
    MAX(a.created_at) as last_activity
FROM recipes r
LEFT JOIN recipe_analytics a ON r.id = a.recipe_id
WHERE a.created_at > NOW() - INTERVAL '30 days'
GROUP BY r.id, r.name, r.cuisine_type, r.total_time_minutes
ORDER BY selection_count DESC;

CREATE UNIQUE INDEX IF NOT EXISTS idx_popular_recipes_id ON popular_recipes(id);

-- Refresh function (call this daily via cron or manually)
CREATE OR REPLACE FUNCTION refresh_popular_recipes()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY popular_recipes;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- 6. Helper Functions
-- ============================================================

-- Function to find recipes by preferences
CREATE OR REPLACE FUNCTION find_matching_recipes(
    p_cuisine TEXT,
    p_meal_types TEXT[],
    p_max_time INT,
    p_exclude_allergens TEXT[] DEFAULT '{}',
    p_taste_prefs TEXT[] DEFAULT '{}',
    p_limit INT DEFAULT 20
)
RETURNS TABLE (
    recipe_id UUID,
    recipe_name TEXT,
    match_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.id,
        r.name,
        -- Simple scoring: more matches = higher score
        (
            CASE WHEN r.cuisine_type = p_cuisine THEN 1 ELSE 0 END +
            CASE WHEN r.meal_type && p_meal_types THEN 1 ELSE 0 END +
            CASE WHEN r.total_time_minutes <= p_max_time THEN 1 ELSE 0 END +
            (SELECT COUNT(*) FROM unnest(r.taste_profile) t WHERE t = ANY(p_taste_prefs))::FLOAT / 
                GREATEST(array_length(p_taste_prefs, 1), 1) +
            r.popularity_score / 100
        ) as score
    FROM recipes r
    WHERE 
        r.cuisine_type = p_cuisine
        AND r.meal_type && p_meal_types
        AND r.total_time_minutes <= p_max_time
        AND NOT (r.allergens && p_exclude_allergens)
    ORDER BY score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to track recipe interactions
CREATE OR REPLACE FUNCTION track_recipe_event(
    p_recipe_id UUID,
    p_event_type TEXT,
    p_session_id TEXT DEFAULT NULL,
    p_preferences JSONB DEFAULT NULL
)
RETURNS void AS $$
BEGIN
    -- Insert analytics event
    INSERT INTO recipe_analytics (recipe_id, event_type, session_id, user_preferences)
    VALUES (p_recipe_id, p_event_type, p_session_id, p_preferences);
    
    -- Update recipe popularity score
    IF p_event_type = 'selected' THEN
        UPDATE recipes 
        SET popularity_score = popularity_score + 1
        WHERE id = p_recipe_id;
    ELSIF p_event_type = 'completed' THEN
        UPDATE recipes 
        SET popularity_score = popularity_score + 2
        WHERE id = p_recipe_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- 7. Sample Data (Optional - Remove in production)
-- ============================================================

-- Insert a sample recipe
INSERT INTO recipes (
    name, 
    cuisine_type, 
    meal_type,
    prep_time_minutes,
    cooking_time_minutes,
    difficulty,
    taste_profile,
    ingredients,
    steps,
    tips
) VALUES (
    'Chicken Biryani',
    'Indian',
    ARRAY['lunch', 'dinner'],
    30,
    45,
    'medium',
    ARRAY['spicy', 'savory'],
    '[
        {"name": "basmati rice", "amount": "2 cups", "optional": false},
        {"name": "chicken", "amount": "500g", "optional": false},
        {"name": "yogurt", "amount": "1 cup", "optional": false},
        {"name": "onions", "amount": "2 large", "optional": false},
        {"name": "biryani masala", "amount": "2 tbsp", "optional": false}
    ]'::jsonb,
    ARRAY[
        'Step 1: Marinate chicken with yogurt and spices for 30 minutes',
        'Step 2: Fry onions until golden brown',
        'Step 3: Cook chicken until 70% done',
        'Step 4: Layer rice and chicken in a pot',
        'Step 5: Seal and cook on low heat for 25 minutes'
    ],
    'Use saffron-infused milk for extra flavor. Let it rest for 10 minutes before serving.'
) ON CONFLICT (name) DO NOTHING;

-- ============================================================
-- 8. Row Level Security (Optional - For Multi-tenant)
-- ============================================================

-- Enable RLS on sessions table
-- ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access their own sessions
-- CREATE POLICY session_isolation ON user_sessions
-- USING (session_id = current_setting('app.current_session_id', true));

-- ============================================================
-- Setup Complete!
-- ============================================================

SELECT 'Database schema created successfully!' as status;
