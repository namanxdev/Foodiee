-- ============================================================
-- Recipe Database Schema for Supabase - INTEGRATED VERSION
-- Run this in Supabase SQL Editor AFTER the existing users table
-- ============================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ============================================================
-- 1. Recipes Table (Core Recipe Data)
-- ============================================================

CREATE TABLE IF NOT EXISTS recipes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE,
    
    -- Categories
    cuisine_type TEXT NOT NULL, -- Indian, Chinese, Italian, Mexican, Japanese
    meal_type TEXT[] NOT NULL, -- {breakfast, lunch, dinner, snack}
    
    -- Cooking info
    prep_time_minutes INT NOT NULL,
    cooking_time_minutes INT NOT NULL,
    total_time_minutes INT GENERATED ALWAYS AS (prep_time_minutes + cooking_time_minutes) STORED,
    difficulty TEXT NOT NULL CHECK (difficulty IN ('easy', 'medium', 'hard')),
    servings INT DEFAULT 4,
    
    -- Taste & Dietary
    taste_profile TEXT[] NOT NULL, -- {sweet, spicy, savory, sour, tangy}
    allergens TEXT[] DEFAULT '{}', -- {dairy, nuts, gluten, shellfish}
    dietary_tags TEXT[] DEFAULT '{}', -- {vegetarian, vegan, gluten-free, keto}
    
    -- Recipe Content
    ingredients JSONB NOT NULL, 
    -- Format: [{"name": "chicken", "amount": "500g", "optional": false}]
    
    steps TEXT[] NOT NULL, 
    -- Format: {"Step 1: ...", "Step 2: ..."}
    
    tips TEXT,
    
    -- Search & Ranking
    embedding vector(768), -- For semantic search using Google's text-embedding-004
    popularity_score FLOAT DEFAULT 0, -- Track which recipes users select
    
    -- Metadata
    source TEXT DEFAULT 'Generated by AI', -- "Generated by AI", "From cookbook X", "User submitted"
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Indexes for fast filtering
CREATE INDEX IF NOT EXISTS idx_recipes_cuisine ON recipes(cuisine_type);
CREATE INDEX IF NOT EXISTS idx_recipes_meal_type ON recipes USING GIN(meal_type);
CREATE INDEX IF NOT EXISTS idx_recipes_taste ON recipes USING GIN(taste_profile);
CREATE INDEX IF NOT EXISTS idx_recipes_dietary ON recipes USING GIN(dietary_tags);
CREATE INDEX IF NOT EXISTS idx_recipes_time ON recipes(total_time_minutes);
CREATE INDEX IF NOT EXISTS idx_recipes_difficulty ON recipes(difficulty);
CREATE INDEX IF NOT EXISTS idx_recipes_popularity ON recipes(popularity_score DESC);

-- Vector search index (for semantic similarity)
CREATE INDEX IF NOT EXISTS idx_recipes_embedding ON recipes 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- ============================================================
-- 2. Recipe Images Table (Image Caching)
-- ============================================================

CREATE TABLE IF NOT EXISTS recipe_images (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
    
    image_type TEXT NOT NULL, -- 'hero', 'step_1', 'step_2', etc.
    image_url TEXT NOT NULL, -- Supabase Storage URL
    thumbnail_url TEXT, -- Smaller version for listings
    
    -- Generation metadata
    prompt_used TEXT,
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    
    UNIQUE(recipe_id, image_type)
);

CREATE INDEX IF NOT EXISTS idx_images_recipe ON recipe_images(recipe_id);
CREATE INDEX IF NOT EXISTS idx_images_type ON recipe_images(image_type);

-- ============================================================
-- 3. User Sessions Table (INTEGRATED with existing users table)
-- ============================================================

CREATE TABLE IF NOT EXISTS user_sessions (
    session_id TEXT PRIMARY KEY,
    
    -- Link to users table (optional - for logged-in users)
    user_email TEXT REFERENCES users(email) ON DELETE SET NULL,
    
    -- User preferences (can be different from saved user prefs)
    user_preferences JSONB NOT NULL,
    
    -- Current state
    current_recipe_id UUID REFERENCES recipes(id) ON DELETE SET NULL,
    current_step_index INT DEFAULT 0,
    completed_steps TEXT[] DEFAULT '{}',
    
    -- Interaction history
    viewed_recipes UUID[] DEFAULT '{}',
    selected_recipe_name TEXT,
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    last_accessed TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '24 hours')
);

CREATE INDEX IF NOT EXISTS idx_sessions_user_email ON user_sessions(user_email);
CREATE INDEX IF NOT EXISTS idx_sessions_last_accessed ON user_sessions(last_accessed);
CREATE INDEX IF NOT EXISTS idx_sessions_expires ON user_sessions(expires_at);

-- ============================================================
-- 4. Recipe Analytics Table (Track Usage)
-- ============================================================

CREATE TABLE IF NOT EXISTS recipe_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
    
    event_type TEXT NOT NULL, -- 'viewed', 'selected', 'completed', 'rated'
    session_id TEXT,
    user_email TEXT REFERENCES users(email) ON DELETE SET NULL,
    
    -- Additional context
    user_preferences JSONB,
    rating INT CHECK (rating >= 1 AND rating <= 5), -- Optional: for future rating feature
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

CREATE INDEX IF NOT EXISTS idx_analytics_recipe ON recipe_analytics(recipe_id);
CREATE INDEX IF NOT EXISTS idx_analytics_event ON recipe_analytics(event_type);
CREATE INDEX IF NOT EXISTS idx_analytics_user ON recipe_analytics(user_email);
CREATE INDEX IF NOT EXISTS idx_analytics_created ON recipe_analytics(created_at);

-- ============================================================
-- 5. User Favorite Recipes (NEW - Link users to recipes)
-- ============================================================

CREATE TABLE IF NOT EXISTS user_favorites (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_email TEXT NOT NULL REFERENCES users(email) ON DELETE CASCADE,
    recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
    
    notes TEXT, -- Personal notes about the recipe
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    
    UNIQUE(user_email, recipe_id)
);

CREATE INDEX IF NOT EXISTS idx_favorites_user ON user_favorites(user_email);
CREATE INDEX IF NOT EXISTS idx_favorites_recipe ON user_favorites(recipe_id);

-- ============================================================
-- 6. Materialized View for Popular Recipes
-- ============================================================

CREATE MATERIALIZED VIEW IF NOT EXISTS popular_recipes AS
SELECT 
    r.id,
    r.name,
    r.cuisine_type,
    r.total_time_minutes,
    r.difficulty,
    COUNT(a.id) FILTER (WHERE a.event_type = 'selected') as selection_count,
    COUNT(a.id) FILTER (WHERE a.event_type = 'completed') as completion_count,
    COUNT(a.id) FILTER (WHERE a.event_type = 'viewed') as view_count,
    AVG(a.rating) FILTER (WHERE a.rating IS NOT NULL) as avg_rating,
    MAX(a.created_at) as last_activity
FROM recipes r
LEFT JOIN recipe_analytics a ON r.id = a.recipe_id
WHERE a.created_at > NOW() - INTERVAL '30 days' OR a.created_at IS NULL
GROUP BY r.id, r.name, r.cuisine_type, r.total_time_minutes, r.difficulty
ORDER BY selection_count DESC NULLS LAST;

CREATE UNIQUE INDEX IF NOT EXISTS idx_popular_recipes_id ON popular_recipes(id);

-- ============================================================
-- 7. Helper Functions
-- ============================================================

-- Function to find recipes by preferences
CREATE OR REPLACE FUNCTION find_matching_recipes(
    p_cuisine TEXT,
    p_meal_types TEXT[],
    p_max_time INT,
    p_exclude_allergens TEXT[] DEFAULT '{}',
    p_taste_prefs TEXT[] DEFAULT '{}',
    p_limit INT DEFAULT 20
)
RETURNS TABLE (
    recipe_id UUID,
    recipe_name TEXT,
    match_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.id,
        r.name,
        -- Simple scoring: more matches = higher score
        (
            CASE WHEN r.cuisine_type = p_cuisine THEN 2 ELSE 0 END +
            CASE WHEN r.meal_type && p_meal_types THEN 2 ELSE 0 END +
            CASE WHEN r.total_time_minutes <= p_max_time THEN 1 ELSE 0 END +
            (SELECT COUNT(*)::float FROM unnest(r.taste_profile) t WHERE t = ANY(p_taste_prefs))::FLOAT / 
                GREATEST(array_length(p_taste_prefs, 1), 1) +
            r.popularity_score / 100
        ) as score
    FROM recipes r
    WHERE 
        r.cuisine_type = p_cuisine
        AND r.meal_type && p_meal_types
        AND r.total_time_minutes <= p_max_time
        AND NOT (r.allergens && p_exclude_allergens)
    ORDER BY score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to track recipe events (automatically updates popularity)
CREATE OR REPLACE FUNCTION track_recipe_event(
    p_recipe_id UUID,
    p_event_type TEXT,
    p_session_id TEXT DEFAULT NULL,
    p_user_email TEXT DEFAULT NULL,
    p_preferences JSONB DEFAULT NULL,
    p_rating INT DEFAULT NULL
)
RETURNS void AS $$
BEGIN
    -- Insert analytics event
    INSERT INTO recipe_analytics (recipe_id, event_type, session_id, user_email, user_preferences, rating)
    VALUES (p_recipe_id, p_event_type, p_session_id, p_user_email, p_preferences, p_rating);
    
    -- Update recipe popularity score
    IF p_event_type = 'selected' THEN
        UPDATE recipes 
        SET popularity_score = popularity_score + 1
        WHERE id = p_recipe_id;
    ELSIF p_event_type = 'completed' THEN
        UPDATE recipes 
        SET popularity_score = popularity_score + 2
        WHERE id = p_recipe_id;
    ELSIF p_event_type = 'rated' AND p_rating IS NOT NULL THEN
        UPDATE recipes 
        SET popularity_score = popularity_score + (p_rating / 5.0)
        WHERE id = p_recipe_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to refresh popular recipes view (run daily via cron)
CREATE OR REPLACE FUNCTION refresh_popular_recipes()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY popular_recipes;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup old sessions (run daily)
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS INT AS $$
DECLARE
    deleted_count INT;
BEGIN
    DELETE FROM user_sessions WHERE expires_at < NOW();
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Auto-update trigger for updated_at
CREATE OR REPLACE FUNCTION update_recipe_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc', NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_recipes_updated_at 
    BEFORE UPDATE ON recipes 
    FOR EACH ROW 
    EXECUTE FUNCTION update_recipe_updated_at();

-- ============================================================
-- 8. Row Level Security (RLS)
-- ============================================================

-- Enable RLS on all tables
ALTER TABLE recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE recipe_images ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE recipe_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_favorites ENABLE ROW LEVEL SECURITY;

-- Policies: Allow read access to everyone, write through API only
CREATE POLICY "Allow public read access to recipes" ON recipes
    FOR SELECT USING (true);

CREATE POLICY "Allow public read access to recipe images" ON recipe_images
    FOR SELECT USING (true);

CREATE POLICY "Allow all operations for authenticated users on sessions" ON user_sessions
    FOR ALL USING (true) WITH CHECK (true);

CREATE POLICY "Allow all operations for analytics" ON recipe_analytics
    FOR ALL USING (true) WITH CHECK (true);

CREATE POLICY "Users can manage their own favorites" ON user_favorites
    FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- 9. Sample Data (Optional - For Testing)
-- ============================================================

-- Insert a sample recipe
INSERT INTO recipes (
    name, cuisine_type, meal_type, prep_time_minutes, cooking_time_minutes,
    difficulty, taste_profile, ingredients, steps, tips
) VALUES (
    'Classic Chicken Biryani',
    'Indian',
    ARRAY['lunch', 'dinner'],
    30, 45, 'medium',
    ARRAY['spicy', 'savory'],
    '[
        {"name": "basmati rice", "amount": "2 cups", "optional": false},
        {"name": "chicken", "amount": "500g", "optional": false},
        {"name": "yogurt", "amount": "1 cup", "optional": false},
        {"name": "onions", "amount": "2 large", "optional": false},
        {"name": "biryani masala", "amount": "2 tbsp", "optional": false},
        {"name": "saffron", "amount": "a pinch", "optional": true}
    ]'::jsonb,
    ARRAY[
        'Step 1: Marinate chicken with yogurt, biryani masala, and spices for 30 minutes',
        'Step 2: Fry sliced onions until golden brown and crispy',
        'Step 3: Cook marinated chicken until 70% done',
        'Step 4: Boil rice separately until 70% cooked, then drain',
        'Step 5: Layer rice and chicken alternately in a heavy-bottomed pot',
        'Step 6: Seal the pot with aluminum foil and lid',
        'Step 7: Cook on low heat (dum) for 25 minutes',
        'Step 8: Let it rest for 10 minutes before serving'
    ],
    'Use saffron-infused milk for extra flavor and color. Garnish with fried onions, fresh mint, and coriander. Serve with raita or curry.'
) ON CONFLICT (name) DO NOTHING;

-- ============================================================
-- Setup Complete!
-- ============================================================

SELECT 
    'Recipe database schema created successfully!' as status,
    (SELECT COUNT(*) FROM recipes) as recipe_count,
    'Ready to populate with recipes!' as next_step;
